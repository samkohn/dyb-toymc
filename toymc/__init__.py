"""This Toy Monte Carlo is designed to produce simulated data streams
consisting of known rates of various event types such as singles,
correlated pairs / IBDs, and muons.

The steps for generating this data stream are relatively simple:

    1. Determine how many events of each type to produce
    2. For each event, produce timestamps uniformly at random within the
       given data-taking time window.
    3. Then generate physical quantities for each event according to the
       instructions provided for each particular event type.
    4. For correlated event chains, generate the time delay for delayed
       events and repeat steps 3 and 4 until all desired events have been
       generated.
    5. Aggregate all events into a list, sort by timestamp, and save
       to a file.

Physically-correlated events (e.g. prompt-delayed or WPMuon-ADMuon) are
treated as a single event type. Their occurrence is determined by the
rate of the physical process that causes the correlated events (e.g.
an IBD interaction, or a muon). For each physical event, the presence
and properties of the actual "triggered events" (i.e. TTree entries)
can be determined, perhaps using some randomness. For example, for the
:py:class:`.Correlated` event type, first the number of prompt-delayed
pairs is determined given the process event rate and data stream
duration. Timestamps for the prompt events are then assigned uniformly
at random. Then, the time delay between prompt and delayed is determined
by sampling an exponential distribution independently for each prompt
event. The position (correlated between prompt and delayed) is similarly
determined for each delayed event based on the corresponding prompt
event's position. This treatment is sufficient to handle the variety of
correlations that appear in the Daya Bay data stream.

Because Daya Bay data files use the ROOT format, this Toy Monte Carlo
only outputs ROOT files.

Running the Toy Monte Carlo
---------------------------

To run the Toy Monte Carlo, create a new script that will contain your
particular configuration. Import :py:mod:`toymc` as well as any event
type classes you'll be using.

To start, you'll need to initialize the :py:class:`ToyMC` object with
your output file location, the DAQ runtime, and optionally a random
seed. You can also customize the name of the output TTrees from their
defaults of ``reco_name="AdSimpleNL"`` and ``calib_name="CalibStats"``.

Next, initialize the event types you'll be using. The built-in
event types are :py:class:`.Single` (uncorrelated events),
:py:class:`.Correlated` (correlated pairs), and :py:class:`Muon` (WP, AD
and Shower muons, and, potentially in a future version, muon-correlated
backgrounds). Each comes with a default configuration that can be
adjusted. For example, you may want to supply a different energy
spectrum or position distribution. More on the interface for specifying
custom distributions later.

Now you need to add the event type objects to the :py:class:`ToyMC`
execution object using the :py:meth:`ToyMC.add_event_type` method.

Lastly, run the Toy Monte Carlo by calling the :py:meth:`ToyMC.run`
method. The output file is automatically saved and closed at the end of
execution.

For a simple working example with all the different event types, see
example.py in the dyb-toymc repository.

Customizing the random generators
---------------------------------

Each event type class relies on functions stored as instance attributes
to characterize the physical quantities that are generated by the Toy
Monte Carlo. I say "functions stored as instance attributes" rather
than "instance methods" because these functions are intended to be
replaced by you, the user, and they don't take ``self`` as an argument.
They also are not defined by the class using ``def`` syntax like an
instance method normally would. Instead they're instantiated to a
default (function) value in the ``__init__`` method, just like any other
instance attribute.

Although the exact function signatures differ slightly depending on
the needs of each event type, they all follow a similar pattern that is
easy to adapt for custom energy spectra, position distributions, etc.

Internally, when a given quantity such as event energy is needed, the
Toy Monte Carlo will look up the appropriate instance attribute and
call the function, supplying as the first parameter a random number
generator (RNG) object (for example, ``obj.energy_spectrum(rng)``).
The ``rng`` object is an instance of the ``numpy.random.Generator``
class, and documentation on available methods can be found online:
<https://numpy.org/doc/stable/reference/random/generator.html>. It is
the responsibility of the function to call whatever random number
generation methods using the ``rng`` parameter, assemble them in some
fancy way, and return the desired value.

.. warning::
   do *not* create your own random generator instance via NumPy or the
   Python random module. The ToyMC library creates a single internal RNG
   that is used for all random number generation.

To customize the behavior (again, for an example, the energy spectrum),
simply define your own function that takes ``rng`` as a parameter and
does what you want with it. For example, here is a simplistic
configuration for an event type that looks like IBD with neutron capture
on hydrogen (nH)::

    >>> ibd_nH = Correlated("IBD nH", 1, 1, 0.006, 150000)
    >>> def nH_delayed_spectrum(rng):  # It's not perfect, but
    >>>     return rng.uniform(1.9, 2.3)  # at least the range is right!
    >>> ibd_nH.delayed_energy_spectrum = nH_delayed_spectrum

Now each time the Toy Monte Carlo needs a value for an nH delayed
energy, it will run the function ``nH_delayed_spectrum`` and supply the
RNG. The returned value in this case is simply chosen uniformly at
random, but it could be quite complicated, e.g. weighted by a histogram.

The documentation for each built-in class specifies the available
attributes that can be customized. A small number of helper methods are
available in the :py:mod:`toymc.util` module.

Creating new event types
------------------------

New event types are easily created by creating a subclass of
:py:class:`toymc.EventType`. You should override ``__init__`` and
``generate_events``. In the latter method, you should include whatever
logic you need to generate your events. You will be provided with a
random number generator (instance of numpy.random.Generator) as the
first parameter. In the built-in event types, most of the logic is
specified in sub-methods to help keep the code clean and readable.

Each event you create (i.e. each element of the list returned by
``generate_events`` must be an instance of :py:class:`toymc.Event`,
which is a ``namedtuple`` class. When you construct these Event objects,
you must provide all 16 attributes in the correct order. They are
also immutable, so you cannot change values from an existing Event
object. You shouldn't have to, though, if you follow the pattern for
generating events from the built-in event types. See the :py:class:`API
documentation for Event <toymc.Event>` for more details.
"""
import argparse
from collections import namedtuple
from operator import attrgetter
from abc import ABC, abstractmethod
from numpy.random import default_rng

import root_util


class ToyMC:
    """The ToyMC top-level manager class.

    This is the class you should create first when you want to set up a
    Toy Monte Carlo script.

    Parameters
    ----------
    outfile : str
        The file name/location for the output ROOT file
    duration : number
        The duration of data taking to generate data for, **in seconds**

    Keyword Arguments
    -----------------
    reco_name : str
        The name of the TTree containing reconstructed data located at
        /Event/Rec
    calib_name : str
        The name of the TTree containing the calibrated statistics data
        located at /Event/Data
    seed : int
        The seed to use for the random number generator. If ``None`` or
        not specified, the random number generator will use a seed
        generated by the system.
    """

    def __init__(
        self,
        outfile,
        duration,
        reco_name="AdSimpleNL",
        calib_name="CalibStats",
        seed=None,
    ):
        from ROOT import TFile  # pylint: disable=no-name-in-module

        self.outfile = TFile(outfile, "RECREATE")
        self.event_types = []
        self.duration = duration
        self.rng = default_rng(seed)
        self.reco_name = reco_name
        self.calib_name = calib_name

    def add_event_type(self, event_type):
        """Add the specified event type to the ToyMC."""
        self.event_types.append(event_type)

    def run(self):
        """Run the ToyMC and save the output."""
        output = MCOutput(
            self.outfile, reco_name=self.reco_name, calib_name=self.calib_name
        )
        events = []
        for event_type in self.event_types:
            new_events = event_type.generate_events(self.rng, self.duration)
            events.extend(new_events)
        events.sort(key=attrgetter("timestamp"))
        for event in events:
            output.add(event)
        self.finalize()

    def finalize(self):
        """Safely save and close out all ToyMC resources."""
        self.outfile.Write()
        self.outfile.Close()


class MCOutput:
    """The ToyMC output data structure (internal class).

    This class is used internally to prepare and fill the output ROOT
    TTrees.

    Parameters
    ----------
    container : ROOT.TFile
        The ``TFile`` that will host the ToyMC output data structures
    reco_name : str
        The name of the reconstructed data TTree
    calib_name : str
        The name of the calibrated statistics TTree
    """

    def __init__(self, container, reco_name, calib_name):
        from ROOT import TTree  # pylint: disable=no-name-in-module

        self.container = container
        self.container.cd()
        self.reco_ttree, self.reco_buf = self.prep_reco(
            TTree, self.container, reco_name
        )
        self.calib_ttree, self.calib_buf = self.prep_calib(
            TTree, self.container, calib_name
        )

    def add(self, event):
        """Add the given event to the output data structure.

        Parameters
        ----------
        event : :py:class:`Event`
            The event to fill into the ToyMC output
        """
        rb = self.reco_buf
        cb = self.calib_buf
        assign_value = root_util.assign_value
        assign_value(cb.triggerNumber, event.trigger_number)
        assign_value(cb.detector, event.detector)
        timestamp_seconds = event.timestamp // 1000000000
        timestamp_nanoseconds = event.timestamp % 1000000000
        assign_value(cb.timestamp_seconds, timestamp_seconds)
        assign_value(cb.timestamp_nanoseconds, timestamp_nanoseconds)
        assign_value(cb.nHit, event.nHit)
        assign_value(cb.charge, event.charge)
        assign_value(cb.fQuad, event.fQuad)
        assign_value(cb.fMax, event.fMax)
        assign_value(cb.fPSD_t1, event.fPSD_t1)
        assign_value(cb.fPSD_t2, event.fPSD_t2)
        assign_value(cb.f2inch_maxQ, event.f2inch_maxQ)

        assign_value(rb.triggerType, event.trigger_type)
        assign_value(rb.site, event.site)
        assign_value(rb.energy, event.energy)
        assign_value(rb.x, event.x)
        assign_value(rb.y, event.y)
        assign_value(rb.z, event.z)

        self.reco_ttree.Fill()
        self.calib_ttree.Fill()

    @staticmethod
    def prep_calib(TTree, host_file, name):
        """Create the "calib" (~CalibStats) TTree and fill buffer.

        Parameters
        ----------
        host_file : ROOT.TFile
            The TFile that will hold the calib TTree
        name : str
            The name of this TTree

        Returns
        -------
        (calib_ttree, buffer) : tuple
            The TTree object and the buffer used to fill its TBranches
        """
        buf = root_util.TreeBuffer()
        buf.triggerNumber = root_util.int_value()
        buf.detector = root_util.int_value()
        buf.timestamp_seconds = root_util.int_value()
        buf.timestamp_nanoseconds = root_util.int_value()
        buf.nHit = root_util.int_value()
        buf.charge = root_util.float_value()
        buf.fQuad = root_util.float_value()
        buf.fMax = root_util.float_value()
        buf.fPSD_t1 = root_util.float_value()
        buf.fPSD_t2 = root_util.float_value()
        buf.f2inch_maxQ = root_util.float_value()

        host_file.cd()
        event_subdir = host_file.Get("Event")
        if not bool(event_subdir):
            event_subdir = host_file.mkdir("Event")
        event_subdir.cd()
        data_subdir = event_subdir.Get("Data")
        if not bool(data_subdir):
            data_subdir = event_subdir.mkdir("Data")
        data_subdir.cd()
        long_name = "Tree at /Event/Data/{name} holding Data_{name}".format(name=name)
        calib = TTree(name, long_name)
        calib.Branch("triggerNumber", buf.triggerNumber, "triggerNumber/I")
        calib.Branch(
            "context.mTimeStamp.mSec",
            buf.timestamp_seconds,
            "context.mTimeStamp.mSec/I",
        )
        calib.Branch(
            "context.mTimeStamp.mNanoSec",
            buf.timestamp_nanoseconds,
            "context.mTimeStamp.mNanoSec/I",
        )
        calib.Branch("context.mDetId", buf.detector, "context.mDetId/I")
        calib.Branch("nHit", buf.nHit, "nHit/I")
        calib.Branch("NominalCharge", buf.charge, "NominalCharge/F")
        calib.Branch("Quadrant", buf.fQuad, "Quadrant/F")
        calib.Branch("MaxQ", buf.fMax, "MaxQ/F")
        calib.Branch("time_PSD", buf.fPSD_t1, "time_PSD/F")
        calib.Branch("time_PSD1", buf.fPSD_t2, "time_PSD1/F")
        calib.Branch("MaxQ_2inchPMT", buf.f2inch_maxQ, "MaxQ_2inchPMT/F")
        return calib, buf

    @staticmethod
    def prep_reco(TTree, host_file, name):
        """Create the "reco" (~AdSimple) TTree and fill buffer.

        Parameters
        ----------
        host_file : ROOT.TFile
            The TFile that will hold the reco TTree
        name : str
            The name of this TTree

        Returns
        -------
        (reco_ttree, buffer) : tuple
            The TTree object and the buffer used to fill its TBranches
        """
        buf = root_util.TreeBuffer()
        buf.triggerType = root_util.unsigned_int_value()
        buf.site = root_util.int_value()
        buf.energy = root_util.float_value()
        buf.x = root_util.float_value()
        buf.y = root_util.float_value()
        buf.z = root_util.float_value()

        host_file.cd()
        event_subdir = host_file.Get("Event")
        if not bool(event_subdir):
            event_subdir = host_file.mkdir("Event")
        event_subdir.cd()
        rec_subdir = event_subdir.Get("Rec")
        if not bool(rec_subdir):
            rec_subdir = event_subdir.mkdir("Rec")
        rec_subdir.cd()
        long_name = "Tree at /Event/Rec/{name} holding Rec_{name}".format(name=name)
        reco = TTree(name, long_name)
        reco.Branch("context.mSite", buf.site, "context.mSite/I")
        reco.Branch("triggerType", buf.triggerType, "triggerType/i")
        reco.Branch("energy", buf.energy, "energy/F")
        reco.Branch("x", buf.x, "x/F")
        reco.Branch("y", buf.y, "y/F")
        reco.Branch("z", buf.z, "z/F")
        return reco, buf


class EventType(ABC):
    """The base class for different event types.

    When you want to create new event types with new behavior, your
    class should inherit from this one (:py:class:`toymc.EventType`)

    Parameters
    ----------
    name : str
        The human-readable name for this event type
    """

    def __init__(self, name):
        self.name = name

    @abstractmethod
    def generate_events(self, rng, duration_s):
        """Generate a list of :py:class:`Event` objects for the given
        duration.

        This is an internal function and is not intended to be called
        by users of the Toy Monte Carlo.

        This method should be overridden by any subclasses. The
        overriding method should use the ``rng`` parameter for any
        randomness that is needed, and should generate events between
        ``t=0`` and ``t=duration_s`` (**in seconds**). The events do not
        need to be sorted or in any particular order. Note that this
        method does not specify the *number* of events to generate. That
        is assumed to be a potentially configurable value or one that
        may be determined with some randomness.

        Parameters
        -----------
        rng : numpy.random.Generator
            The random number generator (RNG) that should be the sole
            source of randomness in the generated events
        duration_s : number
            The length of simulated DAQ time that the events should be
            generated within, **in seconds**

        Returns
        -------
        list of :py:class:`Event`
            The generated events
        """
        return []

    @staticmethod
    def actual_event_count(rng, duration_s, rate_hz):
        """Generate an actual event count given the rate and duration.

        This is a helper method that samples the Poisson distribution
        with a mean representing the number of "expected" events given
        the rate and duration/runtime. Note that for correlated events,
        this is more accurately the number of event "groups" rather than
        the number of sub-events.

        Parameters
        ----------
        duration_s : number
            The length of time the DAQ is being run, **in seconds**
        rate_hz : number
            The event rate, **in hertz**

        Returns
        -------
        number
            The actual count of events to use, sampled at random
        """
        expected_count = duration_s * rate_hz
        return rng.poisson(expected_count)


Event = namedtuple(
    "Event",
    [
        "trigger_number",
        "timestamp",
        "detector",
        "trigger_type",
        "site",
        "energy",
        "nHit",
        "charge",
        "x",
        "y",
        "z",
        "fMax",
        "fQuad",
        "fPSD_t1",
        "fPSD_t2",
        "f2inch_maxQ",
    ],
)

Event.__doc__ += """
The internal representation of a single triggered event.

This class is a ``namedtuple`` type which means it is immutable and has
convenient data access by name/attribute rather than by index. However,
when constructing a new :py:class:`Event` object, you must provide
**all** of the arguments **in the right order**. The order is shown in
the call signature above. Each field's documentation also includes the
(0-based) index corresponding to the correct order.
"""
Event.trigger_number.__doc__ += """

The trigger number for the event, inserted into the ``triggerNumber``
TBranch.
"""
Event.timestamp.__doc__ += """

The event timestamp, as an integer **in nanoseconds**.

In Python 3, integers have no upper bound so using an integer
number of nanoseconds is an ideal way to handle timestamps. The Toy
Monte Carlo will automatically break down this timestamp into the
``context.mTimeStamp.mSec`` and ``context.mTimeStamp.mNanoSec``
TBranches.
"""
Event.detector.__doc__ += """

The event detector (AD), i.e. 1, 2, 3, or 4. Will be inserted into the
``context.mDetId`` TBranch.
"""
Event.trigger_type.__doc__ += """

The event trigger type. Most regular events have a trigger type of
``0x10001100``, which means ESUM and NHIT. Will be inserted into the
``triggerType`` TBranch.
"""
Event.site.__doc__ += """

The event site (EH), i.e. 1, 2, or 4 (for EH3). Will be inserted into
the ``context.mSite`` TBranch.
"""
Event.energy.__doc__ += """

The event energy, in MeV. Will be inserted into the ``energy`` TBranch.
"""
Event.nHit.__doc__ += """

The event nHit value, i.e. number of hit PMTs. Will be inserted into the
``nHit`` TBranch.
"""
Event.charge.__doc__ += """

The event charge value (number of PEs). Will be inserted into the
``NominalCharge`` TBranch.
"""
Event.x.__doc__ += """

The event x position, **in millimeters**. Will be inserted into the
``x`` TBranch.
"""
Event.y.__doc__ += """

The event y position, **in millimeters**. Will be inserted into the
``y`` TBranch.
"""
Event.z.__doc__ += """

The event z position, **in millimeters**. Will be inserted into the
``z`` TBranch.
"""
Event.fMax.__doc__ += """

The maximum charge in any given PMT for the event. Will be inserted into
the ``MaxQ`` TBranch.
"""
Event.fQuad.__doc__ += """

The quadrant value for the event. Will be inserted into the ``Quadrant``
TBranch.
"""
Event.fPSD_t1.__doc__ += """

The first PSD discriminant for the event. Will be inserted into the
``time_PSD`` TBranch.
"""
Event.fPSD_t2.__doc__ += """

The second PSD discriminant for the event. Will be inserted into the
``time_PSD1`` TBranch.
"""
Event.f2inch_maxQ.__doc__ += """

The 2-inch PMT maximum charge value for the event. Will be inserted into
the ``MaxQ_2inchPMT`` TBranch.
"""
